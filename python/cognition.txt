27/09/2023
Лутц Питон т2

Детали реализации класса

Оператор class создает объект.

class имя(суперкласс,...):
	атрибут = значение
	def метод(self, ...):
		self.атрибут = значение
class создает локальное пространство имен у этого объекта.

При выполнении кода class: выполняется весь код, формируется атрибуты класса при присваивании и атрибуты методов при операторах  def

вызов через экземпляр:

экземпляр. метод (аргументы. . .)

вызов через класс:

класс.метод(экземпляр, аргументы…)

__name__ имя класса

абстрактный суперкласс — класс, который от подклассов ждет свое поведение

Х = присваивание ( присваивает в локальной области, если не указан global)
X (ссылка в локальной области, не нашел то в функциях, глобальной области)

object.X = присваивание ( присваивание атрибута объекта)
object.X (ищет в объекте, классах выше)

__class__ - класс экземляра
__bases__ - суперклассы класс
__dict__ - пространство имен экземпляра

Резюме
Узнал о пространстве имен в классах, суперклассах, экземплярах класса, в модуле, в локальной видимости.
Узнал что значит атрибуты класса __class__, __bases__, __dict__, __doc__
узнал как обращаться к атрибутам класса через методы, напрямую, через наследование

В чем основные идеи:  создавать подклассы, которые делают свою логику действий с атрибутами

Как я могу применить изученное: я думаю, что это поможет при создании конвейеров в машинном обучении

Как новое вяжется с тем, что я уже знаю: можно проследить логику работы некоторых фреймворков
стр 118


25.10.2023
Лутц Питон т2

__name__ и __class__ можно составить программу, чтоб показывал все коассы и атрибуты

многостроные комментарии писать в наале программы, в классах, в метододах классов, функиях что делает эта часть кода
# писать на микроуровнях для ясности что и для его делается

модули:
реализуют пакеты данных или логики
создаются файлами кода программы
используются импортированием

классы:
реализуют новые полнофункиональные объекты
создаются оператором class
используют путем обращения к классам
всегда находятся внури модуля

перегрузка операий
__init__ конструктор класса
__sub__  оператор выитания
__del__ уничтожает объект(деструктор)
__add__ операия + X + Y; X += Y(если отсутсвует __iadd__)
__or__ операия ИЛИ |   X | Y ; X |= Y (если отсутвует __ior__)
__repr__, __str__ вывод   print(X), repr(X), str(X)
__call__ вызов функции X(*args, **kwargs)
__getattr__ извлечение атрибута X.undefined
__setattr__ присваивание атрибуту X.any = value
__delattr__ удаление атрибута  del X.any
__getattribute__  извлечение атрибутов X.any
__getitem__ индексирование, срезы, итераия если нет __iter__ X[key], X[i:j]
__setitem__  присваивание по индексу, срезу X[key] = value; X[i:j] = iterable
__delitem__  удаление по индексу, срезу del X[key], X[i:j]
__len__  длина len(X)
__bool__ булевские проверки  bool(X)
__lt__  X<Y
__gt__   X>Y
__le__   X<=Y
__ge__   X>=Y
__eq__   X==Y
__ne__   X!=Y
__radd__  правостороние операии Other + X
__iter__, __next__  итераия I = iter(X), next(X)
__contains__  проверка в членство item in X
__index__  елочисленно значение  hex, bin, oct
__enter__, __exit__  диспетчер контекста with obj as var:
__get__, __set__, __delete__   атрибуты дескриптора  X.attr, X.attr = value
__new__ содание класса перед __init__

__getitem__

def __getitem__(self, index):
	return self.dat[index]

индексирование и нарезание
при нарезание вызывает slice(start,stop,step)
__setitem__

def __setitem__(self,index,value):
	self.data[index] = value

присваивает по индексу или срезу

__getitem__ дает право также итерировать объект, проверять членство, вызов map, списковое включение

__iter__ __next__

проходит один раз по итератору, далее будет пусто

можно сделать проход много раз: применять к базам данных при итераии крупных выюорок

резюме: Узнал о перегрузках операторов классов, об индексации и нарезание объектов класса
и об итераии объектов класса
В чем основные идеи:

Можно создавать  новые объекты на основе классов и задавать им логику при использование стандатных знаков и операторов

Как я могу применить изученное:
могу итерировать, нарезать сложные объекты на основе классов
Как новое вяжется с тем, что я уже знаю:
все возможно!!!
стр 139





























