12,09,23 
совершенный алгоритм радгарфен

алгоритм quickSort

выполняется на месте, не требует памяти
1 выбрать опорный элемент
2 перегруппировать вокруг опорного элемента, меньше опорного, больше опорного и равен опорному
выполняется за О(n)

попрограмма разделение(partition)
вход: массив А, левая(l) и правая( r ) конечные точки массива 
выход: позиция опорного элемента, массив разбит меньше опорного и больше

p: = A[l]
i: = A[l+1]
for j: = l+1 to r do
	if A[j] < p then
		обменять А[j] c A[i]
		i = i+1
обменять А[p] c A[i-1]

return i-1

программа quicksort

вход: массив А, левая(l) и правая( r ) конечные точки массива  
выход отсортрированный массив

if l>=r
	return

i = choosePivot(A, l, r) // выбор опорного элемента

обменять A[l] c A[i] //сделать опорный элемент первым

j = partiton(A, l, r) //новая позиция опрного элемента

quicksort(A, l, j-1)

quicksort(A, j, r)

опорный элемент лучше выбирать рандомизированно

блочная сортировка bucketsort — сортирует числа от0 до 1
разбивает на блоки от 0 до 1/n, 1/n до 2/n  и т. д.

Сортирует каждый блок при помощи insertionSort, затем блоки объединяются

CountingSort разбивает на известное число блоков k, проходит по всему массиву и отправляет число в каждый блок, потом все объединяет


Резюме:
узнал о qiucksort и что сложность это алгоритма на основе сравнения максимальная O(n log n)
выбирается опрный элемент и сравнивается по порядку со всем элементами массива, формируя меньше опрного и больше опрного
далее рекурсивно проходит по частям меньше опрного и больше опрного
опрный элемент выбирается наивно(1 или последний), медианна, и случайно
основная идея: разбить на части меньше опорного и больше опорного и рекурсивно пройти на месте эти части
применить это можно при сортировке массивов
новое вяжется с тем что я знаю: аналог сортировки mergesort, только на месте и вначале разбивка 



