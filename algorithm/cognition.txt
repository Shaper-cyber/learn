05,09,23
построение и анализ
сортировка и порядковая статистика

сортировка используется для чисел и сопутствующей инфрмации

сортировка вставками выполняется на месте, не надо внешней памяти
сортировка слияние нужно дополниельян память
пирамидальная сортирвка О (n lg n) используется структура данных heap
быстрая сортировка на месте O(n2) в худшем случае, О(nlg n) в лушем
сортировка перечислением О(k+n), зависит от размера входного массива
поразрядная сортировка О(d(k+n)) также зависит от  расзмера входного массива
карманная сортирвока зависит от разряда числа от 0 до 1

таблиа времени работы	наихудшее		в среднем
сортировка вставкой		O(n2)			O(n2)
сортировка слиянием		O(n lg n)		O(n lg n)
пирамидальная сортировка	O(n lg n)
быстрая сортиовка		O(n2)			O(n lg n)
сортировка подсчетом	O(k+n)		O(k+n)
поразрядная сортировка	O(d(k	+n))		O(d(k+n))
карманнач сортировка	O(n2)			O(n)

пирамидальная сортировка
полное бинарное дерево(пирамида) в каждом узле элемент массива
у пирамиды есть A.lenght — количество элементов массива
			A.heap-size — количество элементов пирамиды, которые есть в массиве А
корень дерева А[1]
для каждого узла можно узнать родительский идекс, левый и правый дочерний
Parent(i)
	return ceil(i/2)

Left(i)
	return 2*i

Right(i)
	return 2*i + 1
эти операции выполняются быстро битовым сдвигом влево(Left), влево и младший бит 1(Right) и вправо (Parent)
невозрастающая пирамида это A[Parent(i)] >= A[i]

Max-Heapify(A, i) //процедура делает невозрастающую пирамиду
	l = Left(i)
	r = Right(i)
	if l<A.heap-size AND A[l]>A[r]
		largest = l
	else
		largest = i
	if r<=A.heap-size AND A[r]>A[largest]
		largest = r
	if largest<>i
		A[i], A[largest] = A[largest], A[i]
		Max-Heapify(A, largest)
постронеи пирамиды
Build-max-heap(A)
	A.heap-size = A.length
	for i = ceil(A.lenght/2) downto 1
		Max-Heapify(A, i)

резюме
я узнал об бинарном дереве, полное дерево, сбалансированное дерево
узнал что бинарное дерево может быть возрастающим и убывающим
узнал процедуру, которая делает их такими, псевдокод
узнал о пирамидальной сортиовки, что она применяется при поиске больших или маленьких цифрах в массиве
1. В чем основные идеи:
Создать бинарное возрастающее или убывающее дерево
2. Как я могу применить изученное:
Создать структуру данных Heap
3. Как новое ввяжется с тем, что я уже знаю:
Можно сделать поиск по бинарному дереву


12,09,23 
совершенный алгоритм радгарфен

алгоритм quickSort

выполняется на месте, не требует памяти
1 выбрать опорный элемент
2 перегруппировать вокруг опорного элемента, меньше опорного, больше опорного и равен опорному
выполняется за О(n)

попрограмма разделение(partition)
вход: массив А, левая(l) и правая( r ) конечные точки массива 
выход: позиция опорного элемента, массив разбит меньше опорного и больше

p: = A[l]
i: = A[l+1]
for j: = l+1 to r do
	if A[j] < p then
		обменять А[j] c A[i]
		i = i+1
обменять А[p] c A[i-1]

return i-1

программа quicksort

вход: массив А, левая(l) и правая( r ) конечные точки массива  
выход отсортрированный массив

if l>=r
	return

i = choosePivot(A, l, r) // выбор опорного элемента

обменять A[l] c A[i] //сделать опорный элемент первым

j = partiton(A, l, r) //новая позиция опрного элемента

quicksort(A, l, j-1)

quicksort(A, j, r)

опорный элемент лучше выбирать рандомизированно

блочная сортировка bucketsort — сортирует числа от0 до 1
разбивает на блоки от 0 до 1/n, 1/n до 2/n  и т. д.

Сортирует каждый блок при помощи insertionSort, затем блоки объединяются

CountingSort разбивает на известное число блоков k, проходит по всему массиву и отправляет число в каждый блок, потом все объединяет


Резюме:
узнал о qiucksort и что сложность это алгоритма на основе сравнения максимальная O(n log n)
выбирается опрный элемент и сравнивается по порядку со всем элементами массива, формируя меньше опрного и больше опрного
далее рекурсивно проходит по частям меньше опрного и больше опрного
опрный элемент выбирается наивно(1 или последний), медианна, и случайно
основная идея: разбить на части меньше опорного и больше опорного и рекурсивно пройти на месте эти части
применить это можно при сортировке массивов
новое вяжется с тем что я знаю: аналог сортировки mergesort, только на месте и вначале разбивка 



